-module(musem).
-compile([debug_info, nowarn_export_all, export_all, nowarn_unused_function, nowarn_unused_type]).

%  This module implements a minimal but full implementation 
%  for the semantic subtyping framework for the limited type algebra:
%
%  t = 
%   flag
%   | {t, t} 
%   | !t 
%   | t U t 
%   | alpha 
%   | mu alpha . t
%
%  The recursion is explicitly defined via recursion variables and a recursion variable binder.
%  The resulting AST is finite and needs explicit unfolding.
%  Note that there is neither an explicit Any nor an explicit Empty type.
-type ast() :: 
  {flag} 
| {product, ast(), ast()} 
| {negation, ast()}
| {union, ast(), ast()}
| rec_var()
| {mu, rec_var(), ast()}.

%  Recursion variables are indentified by an integer or a name.
%  Usually, a named recursion binder is defined via a user-specified type,
%  and integers are used for recursive types generated by the algorithm.
-type var_name() :: atom() | integer().
-type rec_var() :: {recursion_variable, var_name()}.

%  We can now define some abbreviations.
%  The Any type is a recursive type that unions the flag and recursively the product of itself.
%  It has a fixed name and is denoted by 'any'.
-spec any() -> ast().
any() ->
  Any = {recursion_variable, any},
  {mu, Any, {union, {flag}, {product, Any, Any}}}.

%  The empty type is the negation of any.
-spec empty() -> ast().
empty() ->
  {negation, any()}.
  

%  Everytime we request the Any type, we get a syntactically equivalent Any type. 
%  But creating a semantically equivalent but syntactically different Any type is still possible.
%  There are many equivalence classes which one could consider for sharing types,
%  which are show-cased in this test. 
%  Some sharing is even required for the subtype algorithm to terminate, more on that later.
%    > rebar3 eunit --test musem:any_equivalence_classes_test
-spec any_equivalence_classes_test() -> ok.
any_equivalence_classes_test() ->
  Any = any(), 
  Any = any(), % same

  % equivalence modulo Boolean tautologies
  % e.g. A u A =:= A
  AnyTwice = {union, any(), any()},
  false = Any =:= AnyTwice,
  
  % equivalence modulo mu-renaming
  Var = {recursion_variable, any2},
  AnyMuEquivalent = {mu, Var, {union, {flag}, {product, Var, Var}}},
  false = Any =:= AnyMuEquivalent,

  % equivalence modulo unfolding
  AnyUnfoldedOnce = {union, {flag}, {product, any(), any()}},
  false = Any =:= AnyUnfoldedOnce,

  % ... other classes in between?
  
  % non-trivial semantic equivalence
  AnyEquiv = {union, {flag}, {union, any(), {product, {flag}, {flag}}}},
  false = Any =:= AnyEquiv,

  ok.

%  The subtype algorithm requires the expression to be in disjunctive normal form.
%  For that, we need to introduce the intersection operator.
%  We will not modify the ast. 
%  Instead, we define intersection as a macro expansion in terms of negation and union.
%  Intersections are syntactic sugar.
-define(INTERSECTION(A,B), {negation, {union, {negation, A}, {negation, B}}}).

%  Even more syntactic sugar to create more interesting types: Booleans.
-define(TRUE, {product, {flag}, any()}).
-define(FALSE, {product, any(), {flag}}).
-define(BOOL, {union, ?TRUE, ?FALSE}).

%  To make life a bit easier, 
%  we define a non-reversible pretty-printing function.
% 
%  Pretty-printing can involve custom type representations 
%  for a given syntactical structure of a type (e.g. the any type), 
%  or (further) semantically-equivalent simplification 
%  of the given type (see double negation elemination).
% 
%  This is the first function that works directly on a type.
%  TODO explain: why can this be implemented both recursively and, 
%                even if unnecessary, corecursively (with unfolding and memoization), 
%                whereas the subtype check *must* be implemented corecursively?
-spec print(ast()) -> term().
print(?INTERSECTION(A, B)) -> 
  % The messy 'raw' intersection with negations and unions 
  % is printed as a single intersection symbol.
  {print(A), '&', print(B)};
print(A) -> 
  % registry of type -> pretty printed type
  % This registry can be exposed globally 
  % and user-defined types can be added.
  PrettyRegistry = #{
    any() => any,
    {negation, any()} => empty,
    ?TRUE => 'true',
    ?FALSE => 'false',
    ?BOOL => 'bool'
  },
  case {PrettyRegistry, A} of
    {#{A := Pretty}, _} -> Pretty;
    % simplifications
    % Pretty printing can employ any desired amount of (potentially expensive) simplifications.
    % We eliminate double negation because it is easy to do.
    {_, {negation, {negation, S}}} -> print(S);
    % type constructors
    {_, {flag}} -> flag;
    {_, {product, S, T}} -> {print(S), print(T)};
    % type connectives
    {_, {negation, S}} -> {'!', print(S)};
    {_, {union, S, T}} -> {print(S), u, print(T)};
    % recursion equations
    {_, {recursion_variable, V}} -> V;
    {_, {mu, {recursion_variable, V}, T}} -> {V, '=', print(T)}
  end.

%    > rebar3 eunit --test musem:print_test
-spec print_test() -> ok.
print_test() ->
  any = (Any = print(any())), 
  io:format(user,"Any:~n~p~n", [Any]),
  
  Var = {recursion_variable, any2},
  AnyMuEquivalent = {mu, Var, {union, {flag}, {product, Var, Var}}},
  {V, '=', {flag, u, {V, V}}} = print(AnyMuEquivalent),
  io:format(user,"Pretty custom Any:~n~p~n", [print(AnyMuEquivalent)]),

  % custom type pretty printing
  True = ?TRUE,
  False = ?FALSE,
  Bool = ?BOOL,
  io:format(user,"True and False:~n~p and ~p~nTrue | False: ~p~n", [print(True), print(False), print(Bool)]),
  
  ok.

%  The subtype algorithm assumes a corecursive interpretation of the following grammar:
%  t = flag | {t, t} | !t | t U t 
%  This means neither recursive binders nor recursive variables
%  should ever be encountered during the algorithm.
%  Unfolding all top-level recursive binders once ensures this property.
%  For this, unfolding and mu-substitution is implemented,
%  transforming an ast() to ast_unfolded(), 
%  where mu binders and variables are always below type constructors.
%  Note that we take care that all transformations of ast() 
%  are still subtypes of ast() afterwards.
-type ast_unfolded() :: 
  {flag} 
| {product, ast(), ast()} 
| {negation, ast_unfolded()}
| {union, ast_unfolded(), ast_unfolded()}.

-spec unfold_toplevel_recursive_types(ast()) -> ast_unfolded().
%  We stop at the product type constructor and do not unfold the recursive type binders inside it
unfold_toplevel_recursive_types(P = {product, _, _}) -> P;
%  For a binder, we unfold once and continue recursing until a type constructor is reached
unfold_toplevel_recursive_types(Ty = {mu, Var, InnerTy}) -> 
  substitute(InnerTy, {Var, Ty});
%  For unions and negations, we continue recursing
unfold_toplevel_recursive_types({negation, T}) -> {negation, unfold_toplevel_recursive_types(T)};
unfold_toplevel_recursive_types({union, S, T}) -> {union, unfold_toplevel_recursive_types(S), unfold_toplevel_recursive_types(T)};
unfold_toplevel_recursive_types(T) -> T.

%  Assumption: Var is not contained in a mu binder in InnerTy
-spec substitute(ast(), {rec_var(), ast()}) -> ast().
substitute(V, {Var, Replacement}) when V =:= Var -> Replacement;
substitute({M}, Map) -> {substitute(M, Map)};
substitute({M, S}, Map) -> {M, substitute(S, Map)};
substitute({M, S, T}, Map) -> {M, substitute(S, Map), substitute(T, Map)};
substitute(T, _) -> T.

%    > rebar3 eunit --test musem:any_unfold_test
-spec any_unfold_test() -> ok.
any_unfold_test() ->
  Any = any(),
  any = print(Any),
  empty = print(empty()),
  {flag, u, {any, any}} = print(unfold_toplevel_recursive_types(Any)),
  % unfold non-existant variable
  {flag} = unfold_toplevel_recursive_types({mu, fresh_rec_var(), {flag}}),

  ok.

%  We now define our DNF data structure, which will be a subset of our 'ast()' type.
%  First, we first transform the structure to a negation normal form (NNF), 
%  where the negations are pushed to the atoms.
%  Then, we transform the NNF to the disjunctive normal form (DNF).
% 
%  It should be noted that negations that are part of the intersection 
%  are not considered negations in the NNF sense.
-type ast_nnf() :: 
  {flag} | {negation, {flag}}
| {product, ast(), ast()} | {negation, {product, ast(), ast()}} 
| ?INTERSECTION(ast_nnf(), ast_nnf())
| {union, ast_nnf(), ast_nnf()}.

%  As input we get an unfolded ast() type.
%  Negated intersection and negated unions are transformed with DeMorgan's Law
%  Recurse on intersection and unions
%  Double negation is eliminated
-spec to_nnf(ast_unfolded()) -> ast_nnf().
to_nnf({negation, ?INTERSECTION(A, B)}) -> {union, to_nnf({negation, A}), to_nnf({negation, B})};
to_nnf(?INTERSECTION(A, B)) -> ?INTERSECTION(to_nnf(A), to_nnf(B));
to_nnf({negation, {union, A, B}}) -> ?INTERSECTION(to_nnf({negation, A}), to_nnf({negation, B}));
to_nnf({union, A, B}) -> {union, to_nnf(A), to_nnf(B)};
to_nnf({negation, {negation, A}}) -> to_nnf(A);
to_nnf(A) -> A.


%  We restrict the tree of unions by forcing it to be a list-like type.
%  From now on, we will call these types lists (but not in the sense of Erlang lists).
-type ast_dnf() :: ast_clause() | {union, ast_clause(), ast_dnf()}.
%  Clauses are either a literal or a list of literals.
-type ast_clause() :: ast_literal() | ?INTERSECTION(ast_literal(), ast_clause()).
%  Literals are either type constructors, or the negation thereof. 
-type ast_literal() :: 
  {flag} 
| {product, ast(), ast()} 
| {negation, {flag}} 
| {negation, {product, ast(), ast()}}.


%  The transformation applies the distributive rule recursively.
-spec to_dnf(ast_nnf()) -> ast_dnf().
to_dnf({union, A, B}) ->
  % For unions, union the two disjunctive normal forms.
  ordered_union(to_dnf(A), to_dnf(B));
to_dnf(I = ?INTERSECTION(_A, _B)) ->
  % For intersections, a cartesian product is constructed.
  AllComponents = intersection_to_list(I),
  [FirstDnf | OtherDnfs] = lists:map(fun (C) -> Inner = to_dnf(C), Inner end, AllComponents),

  % transform to a list to be able to use Erlang list comprehensions
  UnionToList = fun U({union, A, B}) -> U(A) ++ U(B); U(A) -> [A] end,
  F = fun(DnfA, DnfB) ->
    [X | Xs] = [ordered_intersection(Ai, Bi) || Ai <- UnionToList(DnfA), Bi <- UnionToList(DnfB)],
    lists:foldl(fun(I1, I2) -> ordered_union(I1, I2) end, X, Xs)
  end,

  lists:foldl(F, FirstDnf, OtherDnfs);
to_dnf(A) ->
  A.

% TODO ugly, figure out how to avoid converting to lists
intersection_to_list(?INTERSECTION(A, B)) ->
  intersection_to_list(A) ++ intersection_to_list(B);
intersection_to_list(A) -> [A].

%  To define fresh variables, we need to generate unique integers.
%  We make use of the Erlang built-in unique_integer/0.
-spec fresh_rec_var() -> rec_var().
fresh_rec_var() -> {recursion_variable, erlang:unique_integer()}.


-spec ordered_union(ast_dnf(), ast_dnf()) -> ast_dnf().
ordered_union({union, IntersectionsA, UnionsB}, U = {union, IntersectionsS, _UnionsT}) when IntersectionsA < IntersectionsS ->
  {union, IntersectionsA, ordered_union(UnionsB, U)};
ordered_union(U = {union, IntersectionsA, _UnionsB}, {union, IntersectionsS, UnionsT}) when IntersectionsS =< IntersectionsA ->
  {union, IntersectionsS, ordered_union(UnionsT, U)};
ordered_union(Intersections, U = {union, IntersectionsS, _UnionsT}) when Intersections < IntersectionsS ->
  {union, Intersections, U};
ordered_union(Intersections, {union, IntersectionsS, UnionsT}) when IntersectionsS =< Intersections ->
  {union, IntersectionsS, ordered_union(Intersections, UnionsT)};
ordered_union(U = {union, _IntersectionsA, _UnionsB}, Intersections) ->
  ordered_union(Intersections, U);
ordered_union(IntersectionsA, IntersectionsS) when IntersectionsA < IntersectionsS ->
  {union, IntersectionsA, IntersectionsS};
ordered_union(IntersectionsA, IntersectionsS) ->
  {union, IntersectionsS, IntersectionsA}.

-spec ordered_intersection(ast_clause(), ast_clause()) -> ast_clause().
ordered_intersection(?INTERSECTION(IntersectionsA, IntersectionsB), I = ?INTERSECTION(IntersectionsS, _IntersectionsT)) 
  when IntersectionsA < IntersectionsS ->
  ?INTERSECTION(IntersectionsA, ordered_intersection(IntersectionsB, I));
ordered_intersection(I = ?INTERSECTION(IntersectionsA, _IntersectionsB), ?INTERSECTION(IntersectionsS, IntersectionsT)) 
  when IntersectionsS < IntersectionsA ->
  ?INTERSECTION(IntersectionsS, ordered_intersection(IntersectionsT, I));
ordered_intersection(?INTERSECTION(IntersectionsA, IntersectionsB), ?INTERSECTION(IntersectionsS, IntersectionsT)) 
  when IntersectionsS =:= IntersectionsA ->
  ?INTERSECTION(IntersectionsA, ordered_intersection(IntersectionsB, IntersectionsT));
ordered_intersection(Intersections, I = ?INTERSECTION(IntersectionsS, _IntersectionsT)) 
  when Intersections < IntersectionsS ->
  ?INTERSECTION(Intersections, I);
ordered_intersection(Intersections, ?INTERSECTION(IntersectionsS, IntersectionsT)) 
  when IntersectionsS < Intersections ->
  ?INTERSECTION(IntersectionsS, ordered_intersection(Intersections, IntersectionsT));
ordered_intersection(Intersections, I = ?INTERSECTION(IntersectionsS, _IntersectionsT)) 
  when IntersectionsS =:= Intersections ->
  I;
ordered_intersection(I = ?INTERSECTION(_IntersectionsA, _IntersectionsB), Intersections) ->
  ordered_intersection(Intersections, I);
ordered_intersection(IntersectionsA, IntersectionsS) when IntersectionsA < IntersectionsS ->
  ?INTERSECTION(IntersectionsA, IntersectionsS);
ordered_intersection(IntersectionsA, IntersectionsS) when IntersectionsA =:= IntersectionsS ->
  IntersectionsA;
ordered_intersection(IntersectionsA, IntersectionsS) when IntersectionsA > IntersectionsS ->
  ?INTERSECTION(IntersectionsS, IntersectionsA).


to_dnf_test() ->
  A = {product, {flag}, any()},
  B = {product, any(), {flag}},

  % order matters
  F = to_dnf({union, A, B}),
  F = to_dnf({union, B, A}),
  
  % !(A & B) == (!a u !b)
  (NNF = {union, {negation, A}, {negation, B}}) = to_nnf(Ty = {negation, ?INTERSECTION(A, B)}),
  io:format(user,"Ty: ~p~nNNF: ~p~n", [print(Ty), print(NNF)]),

  % !(((!P) -> Q) -> R) == ((!A & !B) & !R)
  R = {product, any(), any()},
  (NNF2 = ?INTERSECTION(?INTERSECTION({negation, A}, {negation, B}), {negation, R})) = to_nnf(Ty2 = {negation,{union, {union, {negation, {negation, A}}, B}, R}}),
  io:format(user,"Ty2: ~p~nNNF2: ~p~n", [print(Ty2), print(NNF2)]),

  % (A & (B U T)) == (A & B) U (A & T)
  T = {product, {flag}, {flag}},
  Ty3 = ?INTERSECTION(A, {union, B, T}),
  NNF3 = to_nnf(Ty3),
  io:format(user,"Ty3: ~p~nNNF3: ~p~n", [print(Ty3), print(NNF3)]),
  DNF3 = to_dnf(NNF3),
  io:format(user,"Dnf3: ~p~n", [print(DNF3)]),


  
  ok.


%  Now we can start implementing the subtype algorithm
%  1. Unfold all top-level recursive binders once, such that the mu operator is always only below a type constructor (here, products)
%  2. Convert the ast() type into a top-level DNF
%  3. Simplify each clause into other clauses according to the rules so that each clause has only one type of type constructor (here, either flags or products)
%  4. Solve

is_empty(Ty, Memoized) ->
  io:format(user,"~n~nis_empty: ~p~nmemo: ~p~n", [print(Ty), [print(T) || T <- maps:keys(Memoized)]]),
  Unfolded = unfold_toplevel_recursive_types(Ty),
  Dnf = to_dnf(to_nnf(Unfolded)),
  SplitDnf = split_dnf(Dnf),
  solve(SplitDnf, Memoized).

% -type ast_split_dnf() :: 
%   ast_split_clause({flag}) 
% | ast_split_clause({product, ast(), ast()}) 
% | {union, 
%     ast_split_clause({flag}) | 
%     ast_split_clause({product, ast(), ast()}), 
%     ast_split_dnf()}.
% -type ast_split_clause(Ty) :: ast_literal() | ?INTERSECTION(ast_literal(), ast_clause()).
% %  the DNF does not descend into the types
% -type ast_literal() :: {flag} | {product, ast(), ast()} | {negation, ast_literal()} | rec_var() | {mu, rec_var(), ast()}.

-type ast_unfolded_dnf() :: ast_unfolded_clause() | {union, ast_unfolded_clause(), ast_unfolded_dnf()}.
-type ast_unfolded_clause() :: ast_unfolded_literal() | ?INTERSECTION(ast_unfolded_literal(), ast_unfolded_clause()).
-type ast_unfolded_literal() :: {flag} | {product, ast(), ast()} | {negation, {flag} | {product, ast(), ast()}}.

-spec split_dnf(ast_unfolded_dnf()) -> ast_unfolded_dnf().
split_dnf({union, Clause, Unions}) ->
  D = split_dnf(Clause),
  ordered_union(D, split_dnf(Unions));
split_dnf(Clause) ->
  Cls = intersection_to_list(Clause),
  % positive and negative flags and products
  Pf = [X || X = {flag} <- Cls], 
  Nf = [X || X = {negation, {flag}} <- Cls],
  Pp = [X || X = {product, _A, _B} <- Cls], 
  Np = [X || X = {negation, {product, _A, _B}} <- Cls],

  case {Pf, Nf, Pp, Np} of
    {Pf, [], [], _} when length(Pf) > 0 -> 
      io:format(user,"Only flags: ~p~n", [[print(T) || T <- Cls]]),
      {flag};
    {_, Nf, [], _} when length(Nf) > 0 -> % negated products can be ignored 
      % io:format(user,"Only flag (II) ~p~n", [[print(T) || T <- Cls]]),
      ?INTERSECTION({flag}, {negation, {flag}});
    {[], _, Pp, Np} when length(Pp) > 0 -> % negated flags can be ignored
      io:format(user,"Only products: ~p~n", [[print(T) || T <- Cls]]),
      [X | Xs] = Pp ++ Np,
      ProductClause = lists:foldl(fun ordered_intersection/2, X, Xs),
      ProductClause;
    {[_ | _], _, [_ | _], _} -> 
      % io:format(user,"Mixed positive kinds, intersection is empty~n", []),
      ?INTERSECTION({flag}, {negation, {flag}});
    Z -> % mixed negative can't happen, as soon as a negative flag is in a clause, the intersection is empty
      error({todo, Z, [print(T) || T <- Cls]})
  end.

clause_fold(FlagFun, ProductFun, Join, {union, Clause, Unions}) ->
  Res = clause_fold(FlagFun, ProductFun, Join, Clause),
  Res2 = clause_fold(FlagFun, ProductFun, Join, Unions),
  Join(Res, Res2);
clause_fold(FlagFun, ProductFun, _Join, Clause) ->
  % first element in clause determines its category
  case Clause of
    % flags
    ?INTERSECTION(A, _B) when A == {flag}; A == {negation, {flag}} -> FlagFun(Clause);
    A when A == {flag}; A == {negation, {flag}} -> FlagFun(Clause);

    % products
    ?INTERSECTION({product, _, _}, _B)  -> ProductFun(Clause);
    ?INTERSECTION({negation, {product, _, _}}, _B)  -> ProductFun(Clause);
    {product, _, _}  -> ProductFun(Clause);
    {negation, {product, _, _}} -> ProductFun(Clause)
  end.

solve(SplitDnf, Memoized) -> 
  clause_fold(
    fun(FlagClause) -> 
      Cls = intersection_to_list(FlagClause),
      Pf = [X || X = {flag} <- Cls], 
      Nf = [X || X = {negation, {flag}} <- Cls],
      true = (length(Cls) == length(Pf) + length(Nf)),
      true = (length(Pf) + length(Nf) > 0),
      case {Pf, Nf} of
        {_, [_ | _]} -> true;
        _ -> false
      end
    end,
    fun(ProductClause) -> 
      case Memoized of
        #{ProductClause := true} -> true;
        _ -> 
          solve_product_clause(ProductClause, Memoized#{ProductClause => true}) 
      end
    end,
    fun(R1, R2) -> R1 and R2 end,
    SplitDnf
  ).

solve_product_clause(ProductClause, Memoized) ->
  Cls = intersection_to_list(ProductClause),

  [FirstProduct | Ps] = case [X || X = {product, _ ,_} <- Cls] of [] -> {product, any(), any()}; Z -> Z end, 
  Np = [X || X = {negation, {product, _, _}} <- Cls],

  {product, Ty1, Ty2} = lists:foldl(
    fun({product, P1, P2}, {product, T1, T2}) -> {product, ?INTERSECTION(P1, T1), ?INTERSECTION(P2, T2)} end, 
    FirstProduct, Ps),

  phi(Ty1, Ty2, Np, Memoized).

% Φ(S1 , S2 , ∅ , T1 , T2) = (S1<:T1) or (S2<:T2)
% Φ(S1 , S2 , N ∪ {T1, T2} , Left , Right) = Φ(S1 , S2 , N , Left | T1 , Right) and Φ(S1 , S2 , N , Left , Right | T2)
% -spec phi(ty_ref(), ty_ref(), [ty_ref()], memo()) -> boolean().
phi(S1, S2, N, Memo) -> 
  phi(S1, S2, N, empty(), empty(), Memo).

% -spec phi(ty_ref(), ty_ref(), [ty_ref()], ty_ref(), ty_ref(), memo()) -> boolean().
phi(S1, S2, [], T1, T2, Memo) ->
     is_empty(?INTERSECTION(S1, {negation, T1}), Memo) 
  or is_empty(?INTERSECTION(S2, {negation, T2}), Memo);
phi(S1, S2, [{product, T1, T2} | N], Left, Right, Memo) ->
      phi(S1, S2, N, {union, Left, T1}, Right, Memo) 
  and phi(S1, S2, N , Left, {union, Right, T2}, Memo).
  

register_type_name(X, Name) ->
  put({name, X}, {name, Name}).

is_empty_test() ->
  % basic recursive types
  % false = is_empty(any(), #{}),
  % true = is_empty({negation, any()}, #{}),

  % anonymous recursive types
  % (X, (X, true)) where X = (X, true) | (true, true)
  % XVar = fresh_rec_var(),
  % X = {mu, XVar, {union, {product, XVar, {flag}}, {product, {flag}, {flag}}}},
  % register_type_name(X, my_x_type),
  % Ty = {product, X, {product, X, {flag}}},
  % false = is_empty(Ty, #{}),
  % io:format(user,"~p~n", [print(Ty)]),
  
  % mutually recursive types
  % (true, A) where 
  % A = (B, true) | (true, true)
  % B = (true, A)
  % parsed as
  % Ty = (true, (A = ((B = (true, A)), true) | (true, true)))
  % AVar = fresh_rec_var(),
  % BVar = fresh_rec_var(),
  % B = {mu, BVar, {product, {flag}, AVar}},
  % A = {mu, AVar, {union, {product, B, {flag}}, {product, {flag}, {flag}}}},
  % Ty = {product, {flag}, A},
  % io:format(user,"~p~n", [print(Ty)]),
  % false = is_empty(Ty, #{}),

  % X where 
  % X = (true, Y) | true
  % Y = X
  % parsed as
  % XVar2 = fresh_rec_var(),
  % YVar2 = fresh_rec_var(),
  % Y2 = {mu, YVar2, XVar2},
  % X2 = {mu, XVar2, {union, {product, {flag}, Y2}, {flag}}},
  % Ty2 = X2,
  % io:format(user,"~p~n", [print(Ty2)]),

  ok.
